/*=============================================================================
	UnXC_Arc.h: 
	Hack structs and macros to make Linux builds work in v451

	Revision history:
		* Created by Higor
=============================================================================*/

/*-----------------------------------------------------------------------------
	Archive hack.
	Redisigned so that Win32 compiled code doesn't change.
	
	Usage:
- Cast FArchive* into FArchive_Proxy* and call the Proxy'd functions
- Some of the << operators work as well (structs not yet)
- Use ARCHIVE_DELETE(Ar) to close+null, works with both real and proxy vars
	
	Tip:
- You may use two local variables (FArchive* AR = FArchive_Proxy* AX)
- This way you don't have to typecast all day

	UObject::Serialize():
- This will implicitly use FArchive functions so use this as well.
- I didn't mirror << operator for FName and UObject types so do it manually.
- Another workaround is to create a UProperty for these values. 
** UProperty can serialize if CPF_Native flag isn't set.


	Example:
test
{
	FArchive* SrcFile = GFileManager->OpenFileReader(...);
	FArchive_Proxy* SrcPX = SrcFile;

	SrcPX->Serialize(...);
	SrcPX->Etc...
	ARCHIVE_DELETE( SrcFile);
}

	You can totally skip the FArchive* local and do this as well
	if the compiler lets you do it safely.
FArchive_Proxy* SrcFile = (FArchive_Proxy*) GFileManager->OpenFileReader(...);


	Warning:
If you opened a FArchive* type generated by a user created file manager, you'll
likely have v432 struct sizes and VTable offsets, in this case you'll have to
identify which files have been opened by GFileManager and which have not.

If possible, always use GFileManager unless you REALLY need to create a
FArchive yourself, as with net bunches or memory-only FArchive types
(for whatever reason you need those).
In that case, do not proxy those references.
-----------------------------------------------------------------------------*/

#ifndef _INC_XC_ARC
#define _INC_XC_ARC

#ifdef __LINUX_X86__
//Feel free to modify this expression to fit your own 440 boolean var/check
//Useful when performing different kinds of checks
//Ideally you want b440Net to be a global variable set during 'StaticConstructor' of any native class in this binary
#ifndef ARCHIVE_440
	#define ARCHIVE_440 b440Net
#endif
// UBOOL b440Net = UNetConnection::StaticClass()->GetPropertiesSize() > sizeof(class UNetConnection);
// UBOOL b440Net = ((UClass*)StaticFindObject( UPlayer::StaticClass(), NULL, TEXT("NetConnection")))->GetPropertiesSize >= 16088;

#define PROXY_FUNC( funcname, argsdef, args) \
			virtual void VT_##funcname##argsdef =0; \
			void funcname##argsdef \
			{ \
				if ( ARCHIVE_440 )	VT_##funcname##args; \
				else ((FArchive*)this)->funcname##args; \
			} 

#define PROXY_FUNC_R( funcname, argsdef, args, rettype) \
			virtual rettype VT_##funcname##argsdef =0; \
			rettype funcname##argsdef \
			{ \
				if ( ARCHIVE_440 )	return VT_##funcname##args; \
				else return ((FArchive*)this)->funcname##args; \
			} 

// Object vtable
#define ARCHIVE_DELETE(ar) {if ( ARCHIVE_440 ) delete (FArchive_Proxy*)ar; else delete (FArchive*)ar; ar = NULL; }

class FArchive_Proxy
{
public:

	// Basic VTable copy
	virtual ~FArchive_Proxy()	{}
	
	PROXY_FUNC( Serialize, (void* V, INT Length), (V, Length) );
	PROXY_FUNC( SerializeBits, (void* V, INT LengthSize), (V, LengthSize));
	PROXY_FUNC( SerializeInt, (DWORD& Value, DWORD Max), (Value, Max));
	PROXY_FUNC( Preload, (UObject* Object), (Object) );
	PROXY_FUNC( CountBytes, (SIZE_T InNum, SIZE_T InMax), (InNum, InMax));
	//You can also work around this in UObject::Serialize by exposing object properties into unrealscript
	//This way UProperty will take care of doing this safely instead.
	virtual FArchive_Proxy& operator<<( class FName& N )=0; //CANNOT PROXY, DO THIS MANUALLY IN CODE!!!
	virtual FArchive_Proxy& operator<<( class UObject*& Res )=0; //CANNOT PROXY, DO THIS MANUALLY IN CODE!!!
	PROXY_FUNC_R( MapName, (FName* Name), (Name), INT);
	PROXY_FUNC_R( MapObject, (UObject* Object), (Object), INT);
	PROXY_FUNC_R( Tell, (), (), INT);
	PROXY_FUNC_R( TotalSize, (), (), INT);
	PROXY_FUNC_R( AtEnd, (), (), UBOOL);
	PROXY_FUNC( Seek, (INT InPos), (InPos));
	PROXY_FUNC( AttachLazyLoader, (FLazyLoader* LazyLoader), (LazyLoader));
	PROXY_FUNC( DetachLazyLoader, (FLazyLoader* LazyLoader), (LazyLoader));
	PROXY_FUNC( Precache, (INT HintCount), (HintCount));
	PROXY_FUNC( Flush, (), ());
	PROXY_FUNC_R( Close, (), (), UBOOL);
	PROXY_FUNC_R( GetError, (), (), UBOOL);
	
/*	virtual void _Serialize( void* V, INT Length )	{}
	virtual void _SerializeBits( void* V, INT LengthBits )	{}
	virtual void _SerializeInt( DWORD& Value, DWORD Max )	{}
	virtual void _Preload( UObject* Object )	{}
	virtual void _CountBytes( SIZE_T InNum, SIZE_T InMax )	{}
	virtual FArchive_Proxy& operator<<( class FName& N )	{}
	virtual FArchive_Proxy& operator<<( class UObject*& Res )	{}
	virtual INT _MapName( FName* Name )	{}
	virtual INT _MapObject( UObject* Object )	{}
	virtual INT _Tell()	{ return 0; }
	virtual INT _TotalSize()	{ return 0; }
	virtual UBOOL _AtEnd()	{ return 0; }
	virtual void _Seek( INT InPos )	{}
	virtual void _AttachLazyLoader( FLazyLoader* LazyLoader )	{}
	virtual void _DetachLazyLoader( FLazyLoader* LazyLoader )	{}
	virtual void _Precache( INT HintCount )	{}
	virtual void _Flush()	{}
	virtual UBOOL _Close()	{ return 0;	}
	virtual UBOOL _GetError() {	return 0; }
*/	

	// Constructor.
	FArchive_Proxy()	{}	

	// Status accessors.
	INT Ver()				{return ArVer;}
	INT NetVer()			{return ArNetVer&0x7fffffff;}
	INT LicenseeVer()		{return ArLicenseeVer;}
	UBOOL IsLoading()		{return ArIsLoading;}
	UBOOL IsSaving()		{return ArIsSaving;}
	UBOOL IsTrans()			{return ArIsTrans;}
	UBOOL IsNet()			{return (ArNetVer&0x80000000)!=0;}
	UBOOL IsPersistent()    {return ArIsPersistent;}
	UBOOL IsError()         {return ArIsError;}
	UBOOL ForEdit()			{return ArForEdit;}
	UBOOL ForClient()		{return ArForClient;}
	UBOOL ForServer()		{return ArForServer;}

	// Friend archivers.
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, ANSICHAR& C )
	{
		Ar.Serialize( &C, 1 );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, BYTE& B )
	{
		Ar.Serialize( &B, 1 );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, SBYTE& B )
	{
		Ar.Serialize( &B, 1 );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, _WORD& W )
	{
		Ar.Serialize( &W, sizeof(W) );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, SWORD& S )
	{
		Ar.Serialize( &S, sizeof(S) );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, DWORD& D )
	{
		Ar.Serialize( &D, sizeof(D) );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, INT& I )
	{
		Ar.Serialize( &I, sizeof(I) );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, FLOAT& F )
	{
		Ar.Serialize( &F, sizeof(F) );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy &Ar, QWORD& Q )
	{
		Ar.Serialize( &Q, sizeof(Q) );
		return Ar;
	}
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, SQWORD& S )
	{
		Ar.Serialize( &S, sizeof(S) );
		return Ar;
	}
	
	//Linux string fix
	friend FArchive_Proxy& operator<<( FArchive_Proxy& Ar, FString& A )
	{
		guard(FString<<);
		INT* AA = (INT*)&A; //0 is data pointer, 1 is Num, 2 is Max
		Ar.CountBytes( AA[1], AA[2] ); //Elementsize = 1

		INT SaveNum = AA[1]; //Always pure ANSI in this build
		*(FArchive*)&Ar << AR_INDEX(SaveNum); //May become negative if being loaded

		if( Ar.IsLoading() )
		{
			AA[1] = AA[2] = Abs(SaveNum);
			*((void**)AA) = appRealloc( *((void**)AA), SaveNum, TEXT("FArchive_Proxy") );

			if ( SaveNum )
				check( AA[0] );
			check( AA[1] == SaveNum );

			if( SaveNum > 0 ) //ANSI to ANSI
				Ar.Serialize( *(void**)AA, SaveNum);
			else if ( SaveNum < 0 )
			{
				TCHAR* TT = *((TCHAR**)AA);
				for( INT i=0; i<AA[1]; i++ )
					{UNICHAR UCh; Ar << UCh; TT[i]=FromUnicode(UCh);}
			}
			if( AA[1] == 1 )
				A.Empty();
		}
		else //Always ANSI, serialize in a single call
			Ar.Serialize( *(void**)&A, AA[1] );
		return Ar;
		unguard;
	}
	
public:
	INT ArVer;
	INT ArNetVer;
	INT ArLicenseeVer;
	UBOOL ArIsLoading;
	UBOOL ArIsSaving;
	UBOOL ArIsTrans;
	UBOOL ArIsPersistent;
	UBOOL ArForEdit;
	UBOOL ArForClient;
	UBOOL ArForServer;
	UBOOL ArIsError;
	UBOOL ArContainsCode;
	INT Stopper;
};

//
// Archive constructor.
//
template <class T> T Arctor( FArchive_Proxy& Ar )
{
	T Tmp;
	Ar << Tmp;
	return Tmp;
}


#else
	#define FArchive_Proxy FArchive
	#define ARCHIVE_DELETE(ar) { delete ar; ar = NULL; }
#endif


#endif

